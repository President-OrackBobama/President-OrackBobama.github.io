<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Документация</title>
</head>
<body>
    <h2>Запуск программы</h2>
    <p>Запустить какую-либо программу, например, приведенный выше код, вы можете весьма простым способом с помощью интерактивного интерпретатора F#:</p>
    <ol>
        <li>Нужно подать код самого компилятора в интерпретатор языка F#;</li>
        <li>В этом же интерпретаторе написать команду <code>execute ""</code>, где в кавычках "" нужно вписать файл, содержащий код. Например <code>execute "example1.x"</code></li>
        <li>Будет выдан результат в виде нескольких строк, состоящих из считанного кода и результата его выполнения.</li>
    </ol>

    <h2>Синтаксическое дерево</h2>
    <p>Синтаксическое дерево строится путем комбинирования узлов Expr в соответствии с синтаксисом языка программирования. Например, операторы и их операнды объединяются в узлы OPERATOR, условные выражения представляются узлами CONDEX, а функции и их вызовы создают узлы FUNC и CALL соответственно.</p>
    <p>Каждый узел синтаксического дерева Expr может содержать другие узлы Expr, что позволяет представлять сложные структуры и выражения. Эта структура данных обеспечивает удобное представление синтаксического анализа и интерпретации кода на данном языке программирования.</p>

    <table border="1">
        <tr>
            <th>Тип</th>
            <th>Описание</th>
        </tr>
        <tr>
            <td>NUM</td>
            <td>Представляет числовые значения.</td>
        </tr>
        <tr>
            <td>STRING</td>
            <td>Представляет строковые значения.</td>
        </tr>
        <tr>
            <td>BOOL</td>
            <td>Представляет булевы значения (истина или ложь).</td>
        </tr>
        <tr>
            <td>ID</td>
            <td>Представляет именованные переменные.</td>
        </tr>
        <tr>
            <td>CONDEX</td>
            <td>Представляет условные выражения (условие, то, иначе).</td>
        </tr>
        <tr>
            <td>LET</td>
            <td>Представляет создание именованных переменных (имя, привязываемое значение [не вычисляется при привязке]).</td>
        </tr>
        <tr>
            <td>FUNC</td>
            <td>Представляет объявление функции (имя функции, список аргументов, тело, замыкание, количество аргументов).</td>
        </tr>
        <tr>
            <td>CALL</td>
            <td>Представляет вызов функции (имя вызываемой функции, список аргументов, арность).</td>
        </tr>
        <tr>
            <td>OPERATOR</td>
            <td>Представляет операторы (булевые, числовые или операторы отношения) и список параметров.</td>
        </tr>
    </table>

    <p>Программа принимает вводную строку и разделяет её на отдельные части, называемые токенами. Затем она анализирует последовательность токенов, выполняя парсинг каждого токена отдельно. В процессе анализа, программа пытается сопоставить токены с предопределенными шаблонами и создает структуры данных, называемые ANYLIST.</p>
    <p>ANYLIST - это контейнер для хранения подвыражений, которые нужно вычислить, чтобы получить значение всего выражения. ANY может содержать как одиночные элементы, такие как числа, так и последовательности операций. Все элементы в полученном дереве синтаксиса также являются объектами типа ANYLIST.</p>
    <p>ANYARGLIST - используется для идентификации аргументов функций, которые заключены в фигурные скобки {}. Аргументы собираются в одной переменной и помечаются для дальнейшего применения к соответствующим структурным шаблонам. Функции представляются в виде [ИМЯ; АРГУМЕНТЫ; ТЕЛО и тд].</p>
    <p>ANY - служит для определения ключевых слов и поддерживаемых операторов. Он представляет собой метку для распознанного типа, полученного из токена.</p>
    <p>На выходе из программы получается дерево синтаксиса, которое представляет структуру введенного выражения.</p>

    <h2>Интерпретатор</h2>
    <p>Интерпретатор этой программы работает следующим образом:</p>
    <ol>
        <li>Если необходимо интерпретировать тип ANYLIST, то все его подвыражения интерпретируются. Этот процесс продолжается до тех пор, пока не будет получено значение, не являющееся типом ANY.</li>
        <li>При интерпретации условного выражения сначала вычисляется условие, а затем возвращается соответствующая ветвь выражения без её вычисления.</li>
        <li>Если встречается именованная переменная, то программа обращается к переменной в текущем окружении, и значение этой переменной возвращается.</li>
        <li>При объявлении функции информация о функции записывается в переменное окружение. В информацию о функции также добавляется текущий контекст (переменные окружения) для поддержки замыканий.</li>
        <li>При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами из вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций.</li>
        <li>Для операторов, взаимодействующих со списками аргументов, сначала происходит оценка и проверка типов элементов списка, а затем непосредственное вычисление значения.</li>
        <li>Простейшие типы, такие как числа, строки и логические переменные, возвращают себя же при оценке.</li>
        <li>В соответствии с требованиями языка программирования, интерпретатор возвращает один из подтипов Expr.</li>
    </ol>
    <p>Этот интерпретатор позволяет анализировать и выполнить код, представленный в структуре дерева синтаксиса.</p>
</head>
<body>
    <h2>Запуск программы</h2>
    <p>Запустить какую-либо программу, например, приведенный выше код, вы можете весьма простым способом с помощью интерактивного интерпретатора F#:</p>
    <ol>
        <li>Нужно подать код самого компилятора в интерпретатор языка F#;</li>
        <li>В этом же интерпретаторе написать команду <code>execute ""</code>, где в кавычках "" нужно вписать файл, содержащий код. Например <code>execute "example1.x"</code></li>
        <li>Будет выдан результат в виде нескольких строк, состоящих из считанного кода и результата его выполнения.</li>
    </ol>

    <h2>Синтаксическое дерево</h2>
    <p>Синтаксическое дерево строится путем комбинирования узлов Expr в соответствии с синтаксисом языка программирования. Например, операторы и их операнды объединяются в узлы OPERATOR, условные выражения представляются узлами CONDEX, а функции и их вызовы создают узлы FUNC и CALL соответственно.</p>
    <p>Каждый узел синтаксического дерева Expr может содержать другие узлы Expr, что позволяет представлять сложные структуры и выражения. Эта структура данных обеспечивает удобное представление синтаксического анализа и интерпретации кода на данном языке программирования.</p>

    <table border="1">
        <tr>
            <th>Тип</th>
            <th>Описание</th>
        </tr>
        <tr>
            <td>NUM</td>
            <td>Представляет числовые значения.</td>
        </tr>
        <tr>
            <td>STRING</td>
            <td>Представляет строковые значения.</td>
        </tr>
        <tr>
            <td>BOOL</td>
            <td>Представляет булевы значения (истина или ложь).</td>
        </tr>
        <tr>
            <td>ID</td>
            <td>Представляет именованные переменные.</td>
        </tr>
        <tr>
            <td>CONDEX</td>
            <td>Представляет условные выражения (условие, то, иначе).</td>
        </tr>
        <tr>
            <td>LET</td>
            <td>Представляет создание именованных переменных (имя, привязываемое значение [не вычисляется при привязке]).</td>
        </tr>
        <tr>
            <td>FUNC</td>
            <td>Представляет объявление функции (имя функции, список аргументов, тело, замыкание, количество аргументов).</td>
        </tr>
        <tr>
            <td>CALL</td>
            <td>Представляет вызов функции (имя вызываемой функции, список аргументов, арность).</td>
        </tr>
        <tr>
            <td>OPERATOR</td>
            <td>Представляет операторы (булевые, числовые или операторы отношения) и список параметров.</td>
        </tr>
    </table>

    <p>Программа принимает вводную строку и разделяет её на отдельные части, называемые токенами. Затем она анализирует последовательность токенов, выполняя парсинг каждого токена отдельно. В процессе анализа, программа пытается сопоставить токены с предопределенными шаблонами и создает структуры данных, называемые ANYLIST.</p>
    <p>ANYLIST - это контейнер для хранения подвыражений, которые нужно вычислить, чтобы получить значение всего выражения. ANY может содержать как одиночные элементы, такие как числа, так и последовательности операций. Все элементы в полученном дереве синтаксиса также являются объектами типа ANYLIST.</p>
    <p>ANYARGLIST - используется для идентификации аргументов функций, которые заключены в фигурные скобки {}. Аргументы собираются в одной переменной и помечаются для дальнейшего применения к соответствующим структурным шаблонам. Функции представляются в виде [ИМЯ; АРГУМЕНТЫ; ТЕЛО и тд].</p>
    <p>ANY - служит для определения ключевых слов и поддерживаемых операторов. Он представляет собой метку для распознанного типа, полученного из токена.</p>
    <p>На выходе из программы получается дерево синтаксиса, которое представляет структуру введенного выражения.</p>

    <h2>Интерпретатор</h2>
    <p>Интерпретатор этой программы работает следующим образом:</p>
    <ol>
        <li>Если необходимо интерпретировать тип ANYLIST, то все его подвыражения интерпретируются. Этот процесс продолжается до тех пор, пока не будет получено значение, не являющееся типом ANY.</li>
        <li>При интерпретации условного выражения сначала вычисляется условие, а затем возвращается соответствующая ветвь выражения без её вычисления.</li>
        <li>Если встречается именованная переменная, то программа обращается к переменной в текущем окружении, и значение этой переменной возвращается.</li>
        <li>При объявлении функции информация о функции записывается в переменное окружение. В информацию о функции также добавляется текущий контекст (переменные окружения) для поддержки замыканий.</li>
        <li>При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами из вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций.</li>
        <li>Для операторов, взаимодействующих со списками аргументов, сначала происходит оценка и проверка типов элементов списка, а затем непосредственное вычисление значения.</li>
        <li>Простейшие типы, такие как числа, строки и логические переменные, возвращают себя же при оценке.</li>
        <li>В соответствии с требованиями языка программирования, интерпретатор возвращает один из подтипов Expr.</li>
    </ol>
    <p>Этот интерпретатор позволяет анализировать и выполнить код, представленный в структуре дерева синтаксиса.</p>

    <h3>Булевые выражения</h3>
    <p>Реализованы конъюнкция (обозначенный <code>&amp;</code>) и дизъюнкция (обозначенный <code>|</code>). Работают так же как и математический операции: для списка аргументов длины 1, возвращается значение головы списка.</p>
    <p>Булевые константы <code>true</code> и <code>false</code> записываются с маленькой буквы и без кавычек.</p>
    <p>В качестве аргументов в функции могут передаваться как булевые переменные, так и числовые. Перевод числовых переменных в булевые осуществляется как и во многих ЯП: 0 - это <code>false</code>, а все остальное - <code>true</code>.</p>
    <h4>Примеры</h4>
    <pre>
<code>
  (| 0 1) # true
  (& 0 1) # false
  (| true 0) # true
  (& true (&lt; 10 1)) # false
</code>
    </pre>

    <h3>Строковые литералы</h3>
    <p>Строковые литералы объявляются в программе как строка, обернутая кавычками.</p>
    <h4>Пример</h4>
    <pre>
<code>
  ("Hello, World!") # вернёт строку Hello, World!
</code>
    </pre>

    <h3>Операторы отношения</h3>
    <p>Есть поддержка операторов, таких как <code>&lt;</code>, <code>&gt;</code> и <code>=</code>. Они принимают на вход не более двух аргументов и возвращают <code>true</code> или <code>false</code>. Можно производить сравнение между числами, строками и булевыми значениями.</p>
    <h4>Примеры</h4>
    <pre>
<code>
  (&lt; 2 1) # false
  (= true true) # true
  (&gt; 10 5) # true
  (| (&lt; 1 1) (= 1 1)) # Пример использования &lt;=. Возвращаемое значение - true
</code>
    </pre>

    <h3>Именованные переменные</h3>
    <p>Чтобы создать переменную нужно написать <code>(var id Expr)</code>. <code>id</code> - строка без кавычек, значение <code>Expr</code> вычисляется только в случае, если операции возвращают какое-то значение. Возвращаемое значение - <code>Expr.ANY</code>.</p>
    <h4>Примеры</h4>
    <pre>
<code>
  (var id "string") # будет произведена запись переменной со значением "string"
  
  (var id2 (* 1.5 3.0)) # будет произведена запись переменной со значением OPERATOR(*, [1.5,3.0])
</code>
    </pre>

    <h3>Условные выражения</h3>
    <p>Присутствует поддержка условных выражений. Для создания такого выражения нужно воспользоваться синтаксисом - <code>(if Expr then Expr else Expr)</code>. При вызове будет оценено значение, стоящее после if. Возвращаемое значение будет <code>Expr</code>.</p>
    <p><strong>Замечание:</strong> <code>else</code> можно опустить. Вместо этого будет подставлено значение <code>Expr.ANY</code>.</p>
    <h4>Примеры</h4>
    <pre>
<code>
  (if true then "true" else "false") # вернёт "true"
  
  (if false then "Whatever") # вернёт ANY("")
</code>
    </pre>

    <h3>Функции</h3>
    <p>Чтобы создать функцию, используйте синтаксис: <code>(def func_name { arg1 arg2 } (Expr))</code>. Имя и аргументы функции представляют собой строки без кавычек и могут не иметь аргументов. При вызове функции проверяется количество аргументов и происходит сопоставление с аргументами функции. Из-за замыканий любая функция может стать рекурсивной. Возвращаемое значение — <code>Expr.ANY</code>.</p>
    <h4>Примеры</h4>
    <pre>
<code>
(def fun_2 {a} 
  (if (&lt; a 10)
    then ((sout a) (fun_2 (+ a 1))) 
  else "function completed")
) 
(fun_2 1) # рекурсивная функция, которая выводит значения от 1 до 9, а потом завершается строкой "function completed"
</code>
    </pre>

    <h3>Комментарии</h3>
    <p><code>#</code> - строчный комментарий, при использовании которого содержимое до конца строки отбрасывается.</p>
    <p><code>$...$</code> - комментарий от символа до символа, при использовании которого содержимое игнорируется от <code>$</code> до <code>$</code>.</p>

    <h3>Функция печати</h3>
    <p>Функция <code>sout</code> используется для отображения переменных и может выводить числовые, строковые и логические значения (имеются в виду вычисляемые типы значений).</p>
    <h4>Примеры</h4>
    <pre>
<code>
  (sout "hello") # выведется "hello"
  
  ((var id "world") (sout id)) # выведет "world"
</code>
    </pre>
</body>
</html>

