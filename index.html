<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Документация</title>
</head>
<body>
    <h2>Запуск программы</h2>
    <p>Запустить какую-либо программу, например, приведенный выше код, вы можете весьма простым способом с помощью интерактивного интерпретатора F#:</p>
    <ol>
        <li>Нужно подать код самого компилятора в интерпретатор языка F#;</li>
        <li>В этом же интерпретаторе написать команду <code>execute ""</code>, где в кавычках "" нужно вписать файл, содержащий код. Например <code>execute "example1.x"</code></li>
        <li>Будет выдан результат в виде нескольких строк, состоящих из считанного кода и результата его выполнения.</li>
    </ol>

    <h2>Синтаксическое дерево</h2>
    <p>Синтаксическое дерево строится путем комбинирования узлов Expr в соответствии с синтаксисом языка программирования. Например, операторы и их операнды объединяются в узлы OPERATOR, условные выражения представляются узлами CONDEX, а функции и их вызовы создают узлы FUNC и CALL соответственно.</p>
    <p>Каждый узел синтаксического дерева Expr может содержать другие узлы Expr, что позволяет представлять сложные структуры и выражения. Эта структура данных обеспечивает удобное представление синтаксического анализа и интерпретации кода на данном языке программирования.</p>

    <table border="1">
        <tr>
            <th>Тип</th>
            <th>Описание</th>
        </tr>
        <tr>
            <td>NUM</td>
            <td>Представляет числовые значения.</td>
        </tr>
        <tr>
            <td>STRING</td>
            <td>Представляет строковые значения.</td>
        </tr>
        <tr>
            <td>BOOL</td>
            <td>Представляет булевы значения (истина или ложь).</td>
        </tr>
        <tr>
            <td>ID</td>
            <td>Представляет именованные переменные.</td>
        </tr>
        <tr>
            <td>CONDEX</td>
            <td>Представляет условные выражения (условие, то, иначе).</td>
        </tr>
        <tr>
            <td>LET</td>
            <td>Представляет создание именованных переменных (имя, привязываемое значение [не вычисляется при привязке]).</td>
        </tr>
        <tr>
            <td>FUNC</td>
            <td>Представляет объявление функции (имя функции, список аргументов, тело, замыкание, количество аргументов).</td>
        </tr>
        <tr>
            <td>CALL</td>
            <td>Представляет вызов функции (имя вызываемой функции, список аргументов, арность).</td>
        </tr>
        <tr>
            <td>OPERATOR</td>
            <td>Представляет операторы (булевые, числовые или операторы отношения) и список параметров.</td>
        </tr>
    </table>

    <p>Программа принимает вводную строку и разделяет её на отдельные части, называемые токенами. Затем она анализирует последовательность токенов, выполняя парсинг каждого токена отдельно. В процессе анализа, программа пытается сопоставить токены с предопределенными шаблонами и создает структуры данных, называемые ANYLIST.</p>
    <p>ANYLIST - это контейнер для хранения подвыражений, которые нужно вычислить, чтобы получить значение всего выражения. ANY может содержать как одиночные элементы, такие как числа, так и последовательности операций. Все элементы в полученном дереве синтаксиса также являются объектами типа ANYLIST.</p>
    <p>ANYARGLIST - используется для идентификации аргументов функций, которые заключены в фигурные скобки {}. Аргументы собираются в одной переменной и помечаются для дальнейшего применения к соответствующим структурным шаблонам. Функции представляются в виде [ИМЯ; АРГУМЕНТЫ; ТЕЛО и тд].</p>
    <p>ANY - служит для определения ключевых слов и поддерживаемых операторов. Он представляет собой метку для распознанного типа, полученного из токена.</p>
    <p>На выходе из программы получается дерево синтаксиса, которое представляет структуру введенного выражения.</p>

    <h2>Интерпретатор</h2>
    <p>Интерпретатор этой программы работает следующим образом:</p>
    <ol>
        <li>Если необходимо интерпретировать тип ANYLIST, то все его подвыражения интерпретируются. Этот процесс продолжается до тех пор, пока не будет получено значение, не являющееся типом ANY.</li>
        <li>При интерпретации условного выражения сначала вычисляется условие, а затем возвращается соответствующая ветвь выражения без её вычисления.</li>
        <li>Если встречается именованная переменная, то программа обращается к переменной в текущем окружении, и значение этой переменной возвращается.</li>
        <li>При объявлении функции информация о функции записывается в переменное окружение. В информацию о функции также добавляется текущий контекст (переменные окружения) для поддержки замыканий.</li>
        <li>При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами из вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций.</li>
        <li>Для операторов, взаимодействующих со списками аргументов, сначала происходит оценка и проверка типов элементов списка, а затем непосредственное вычисление значения.</li>
        <li>Простейшие типы, такие как числа, строки и логические переменные, возвращают себя же при оценке.</li>
        <li>В соответствии с требованиями языка программирования, интерпретатор возвращает один из подтипов Expr.</li>
    </ol>
    <p>Этот интерпретатор позволяет анализировать и выполнить код, представленный в структуре дерева синтаксиса.</p>
</body>
</html>
