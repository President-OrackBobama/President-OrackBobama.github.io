
## Запуск программы
Запустить какую-либо программу, например, приведенный выше код, вы можете весьма простым способом с помощью интерактивного интерпретатора F#:

1. Нужно подать код самого компилятора в интерпретатор языка F#;
2. В этом же интерпретаторе написать команду `execute ""`, где в кавычках " " нужно вписать файл, содержащий код. Например `execute "example1.x"` 
3. Будет выдан результат в виде нескольких строк, состоящих из считанного кода и результата его выполнения.

## Синтаксическое дерево

Синтаксическое дерево строится путем комбинирования узлов Expr в соответствии с синтаксисом языка программирования. Например, операторы и их операнды объединяются в узлы OPERATOR, условные выражения представляются узлами CONDEX, а функции и их вызовы создают узлы FUNC и CALL соответственно.

Каждый узел синтаксического дерева Expr может содержать другие узлы Expr, что позволяет представлять сложные структуры и выражения. Эта структура данных обеспечивает удобное представление синтаксического анализа и интерпретации кода на данном языке программирования.

| Тип      | Описание                                                                                                  |
| -------- | --------------------------------------------------------------------------------------------------------- |
| NUM      | Представляет числовые значения.                                                                           |
| STRING   | Представляет строковые значения.                                                                          |
| BOOL     | Представляет булевы значения (истина или ложь).                                                           |
| ID       | Представляет именованные переменные.                                                                      |
| CONDEX   | Представляет условные выражения (условие, то, иначе).                                                     |
| LET      | Представляет создание именованных переменных (имя, привязываемое значение [не вычисляется при привязке]). |
| FUNC     | Представляет объявление функции (имя функции, список аргументов, тело, замыкание, количество аргументов). |
| CALL     | Представляет вызов функции (имя вызываемой функции, список аргументов, арность).                          |
| OPERATOR | Представляет операторы (булевые, числовые или операторы отношения) и список параметров.                   |


Программа принимает вводную строку и разделяет её на отдельные части, называемые токенами. Затем она анализирует последовательность токенов, выполняя парсинг каждого токена отдельно. В процессе анализа, программа пытается сопоставить токены с предопределенными шаблонами и создает структуры данных, называемые ANYLIST.

ANYLIST - это контейнер для хранения подвыражений, которые нужно вычислить, чтобы получить значение всего выражения. ANY может содержать как одиночные элементы, такие как числа, так и последовательности операций. Все элементы в полученном дереве синтаксиса также являются объектами типа ANYLIST.

ANYARGLIST - используется для идентификации аргументов функций, которые заключены в фигурные скобки {}. Аргументы собираются в одной переменной и помечаются для дальнейшего применения к соответствующим структурным шаблонам. Функции представляются в виде [ИМЯ; АРГУМЕНТЫ; ТЕЛО и тд].

ANY - служит для определения ключевых слов и поддерживаемых операторов. Он представляет собой метку для распознанного типа, полученного из токена.

На выходе из программы получается дерево синтаксиса, которое представляет структуру введенного выражения.

## Интерпретатор

Интерпретатор этой программы работает следующим образом:

1. Если необходимо интерпретировать тип ANYLIST, то все его подвыражения интерпретируются. Этот процесс продолжается до тех пор, пока не будет получено значение, не являющееся типом ANY.

2. При интерпретации условного выражения сначала вычисляется условие, а затем возвращается соответствующая ветвь выражения без её вычисления.

3. Если встречается именованная переменная, то программа обращается к переменной в текущем окружении, и значение этой переменной возвращается.

4. При объявлении функции информация о функции записывается в переменное окружение. В информацию о функции также добавляется текущий контекст (переменные окружения) для поддержки замыканий.

5. При вызове функции проверяется соответствие количества аргументов объявленной и вызываемой функции. Затем аргументы функции связываются с параметрами из вызова, и вместе с сохраненным окружением используются для интерпретации тела функции. В этом процессе также учитывается информация о самой функции, что позволяет осуществлять рекурсивные вызовы функций.

6. Для операторов, взаимодействующих со списками аргументов, сначала происходит оценка и проверка типов элементов списка, а затем непосредственное вычисление значения.

7. Простейшие типы, такие как числа, строки и логические переменные, возвращают себя же при оценке.

8. В соответствии с требованиями языка программирования, интерпретатор возвращает один из подтипов Expr.

Этот интерпретатор позволяет анализировать и выполнить код, представленный в структуре дерева синтаксиса.

### Булевые выражения

Реализованы конъюнкция (обозначенный `&`) и дизъюнкция (обозначенный `|`).
Работают так же как и математический операции: для списка аргументов длины 1, возвращается значение головы списка.

Булевые константы `true` и `false` записываются с маленькой буквы и без кавычек.

В качестве аргументов в функции могут передаваться как булевые переменные, так и числовые. Перевод числовых переменных в булевые осуществляется как и во многих ЯП:  0 - это `false`, а все остальное - `true`.

#### Примеры

``` 
  (| 0 1) # true
  (& 0 1) # false
  (| true 0) # true
  (& true (< 10 1)) # false
```

### Строковые литералы

Строковые литералы объявляются в программе как строка, обернутая кавычками.
#### Пример
```
  ("Hello, World!") # вернёт строку Hello, World!
```
### Операторы отношения

Есть поддержка операторов, таких как `<`, `>` и `=`. Они принимают на вход не более двух аргументов и возвращают `true` или `false`. Можно производить сравнение между числами, строками и булевыми значениями.  

#### Примеры

``` 
  (< 2 1) # false
  (= true true) # true
  (> 10 5) # true
  (| (< 1 1) (= 1 1)) # Пример использования <=. Возвращаемое значение - true
```

### Именованные переменные

Чтобы создать переменную нужно написать `(var id Expr)`. `id` - строка без кавычек, значение `Expr` вычисляется только в случае, если операции возвращают какое-то значение. Возвращаемое значение - `Expr.ANY`.

#### Примеры

``` 
  (var id "string") # будет произведена запись переменной со значением "string"
  
  (var id2 (* 1.5 3.0)) # будет произведена запись переменной со значением OPERATOR(*, [1.5,3.0])
```

### Условные выражения

Присутствует поддержка условных выражений. Для создания такого выражения нужно воспользоваться синтаксисом - `(if Expr then Expr else Expr)`. При вызове будет оценено значение, стоящее после if. Возвращаемое значение будет `Expr`.

#### Замечание
`else` можно опустить. Вместо этого будет подставлено значение Expr.ANY.

#### Примеры

``` 
  (if true then "true" else "false") # вернёт "true"
  
  (if false then "Whatever") # вернёт ANY("")
```

### Функции

Чтобы создать функцию, используйте синтаксис: (def func_name { arg1 arg2 } (Expr)). Имя и аргументы функции представляют собой строки без кавычек и могут не иметь аргументов. При вызове функции проверяется количество аргументов и происходит сопоставление с аргументами функции. Из-за замыканий любая функция может стать рекурсивной. Возвращаемое значение — Expr.ANY.

#### Примеры

``` 
(def fun_2 {a} 
  (if (< a 10)
    then ((sout a) (fun_2 (+ a 1))) 
  else "function completed")
) 
(fun_2 1) # рекурсивная функция, которая выводит значения от 1 до 9, а потом завершается строкой "function completed"
```

### Комментарии 

`#` - строчный комментарий, при использовании которого содержимое до конца строки отбрасывается.

`$...$` - комментарий от символа до символа, при использовании которого содержимое игнорируется от @ до @. 

### Функция печати 

Функция `sout` используется для отображения переменных и может выводить числовые, строковые и логические значения (имеются в виду вычисляемые типы значений).

#### Примеры

``` 
  (sout "hello") # выведется "hello"
  
  ((var id "world") (sout id)) # выведет "world"
```

